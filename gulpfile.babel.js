/**********************************************************************************
 **********************************************************************************
 * Gulp Build Design.
 * ****
 * => [build:validate:<env>] run the same validation as in the pre-commit git hook :
 *       -> it is forbidden to commit any JavaScript file that is not validated by prettier.
 *       -> That's for JavaScript, and we wopuld love to have same prettier concept for all of html, sass, scss, javascript files.
 *       -> i will probably achieve implementation of this prettier githook by using https://github.com/okonet/lint-staged as recommended as first option, by prettier project : https://prettier.io/docs/en/precommit.html#option-1-lint-stagedhttpsgithubcomokonetlint-staged
 *       -> So now the question is : once 'lint-staged' is installed how to I run on demand, the validation command , as a gulp task?
 *       -> https://codeburst.io/continuous-integration-lint-staged-husky-pre-commit-hook-test-setup-47f8172924fc
 *       -> I want to try running https://github.com/azz/pretty-quick : to see if it is any easier/Efficient to use compared to [lint-staged]
 *       -> ------
 *       -> so ok, anyway, the idea is :
 *             + I want to force using one formatting convention on all languages used in the source code files.
 *             + I want that format validation to be run on precommit git hook, to prevent any engioneer from commiting a non-formatted source code files.
 *             + And I want that exact same format validation to be run as first validtion step of the gulp build, to prevent any engineer from debuuging a non formatted source code (so only for dev environment builds), and to prevent packaging (and publishing) any product, if it has not bneen compiled from perfectly formatted source code files.
 *             + So i need to find the best tool to do that, among 'lint-staged' and 'pretty-quick'
 *             + I had a look at extended prettier features, and for a start, i will beautify all *.HTML *.CSS *.S?SS *.JS files with prettier, all of them. the prettierrc we want is generated by the prettier playground. ii'll use prettier-eslint setup https://www.youtube.com/watch?v=SydnKbGc7W8 https://www.npmjs.com/package/eslint-config-airbnb
 *
 * => [build:hugo:<env>] The hugo build is done and its results sits in the './public/' folder.
 * => [build:dist:<env>] The content of the './public/' folder is copied to the './dist/' folder.
 * => [clean:sass:<env>] The './dist/sass' folder is deleted : the sass source fiels are not packaged for any deployment of the website.
 * => [build:sass:<env>] The Sass files in the './public/sass/' folder are compiled to the './dist/css/' folder.
 * => [build:interpolate:<env>] In all HTML files inside the 'dist' folder, the interpolation of <link> HTML tags for all Sass compiled files: Interpolation
 * => If it is dev environment :
 *   => all the HTML files are processed to be "debug-friendly" for dev : HTML is beautified
 *   => all the CSS files are processed to be "debug-friendly" for dev : sass files are compiled wiht source map fiels, so that debuggers can use those source maps files for debugging
 *   => all the JavaScript files are processed to be "debug-friendly" for dev : they are beautified, and actually i want to apply prettierrc confifugration to make iot all clear
 *   => In all HTML files inside the 'dist' folder, the interpolation of <script> HTML tags:
 *         => to update the 'src' attributes of '<script>' HTML tags, with the dev name of the beautified JavaScript source files e.g. "radiojaune.com.js"
 *         => to update the 'href' or 'src' attributes of '<link>' HTML tags, with the name of the generated css files : Gulp discovers all the file path of all [*.scss] and [*.sass] files, in the './public/sass/' folder, and for each discovered file path :
 *              -> two file paths are generated : e.g. for the './public/sass/a/b/c/d/e/f/myfile.scss' file, Gulp will generate './public/sass/a/b/c/d/e/f/myfile.min.css' and  './public/sass/a/b/c/d/e/f/myfile.map.css'
 *              -> './public/sass/' is replaced by './dist/css/' : e.g. for the './public/sass/a/b/c/d/e/f/myfile.scss' file, Gulp will generate './public/sass/a/b/c/d/e/f/myfile.min.css' and  './public/sass/a/b/c/d/e/f/myfile.map.css'
 *
 * => If it is production environment :
 *   => all the HTML files are processed to be optimized for production : minified, purged
 *   => all the CSS files are processed to be optimized for production : minified, purgeCSS, cleancss, (and tree shaking by parcel ?)
 *   => all the JavaScript files are processed to be optimized for production : they are uglified and then minified, and probalbly all javascript files are meged into on and only one
 *   => In all HTML files inside the 'dist' folder, the interpolation of <script> HTML tags: to update the 'src' attributes of <script> tag, with the production name of the minified JavaScript file e.g. "radiojaune.com.min.js"
 *
 * First design concept :
 * -> For a build step to be idempotent as an abstract operation,
 * -> it must not EVER modify the source files it works from.
 * -> A bit like the Visitor pattern for compilers.
 *
 * Second design concept (will be implemented later) (beta) :
 * -> [Bower.io] was great to resolve dependencies. [Bower.io] does not exists anymore (is not supported anymore), and recommends using other package managers like parcel, webpack, etc....
 * -> I know that Parcel is really good at mlanaging dependencies
 * -> I don't want Parcel to manage minification, sass compilation or any transformation tasks.
 * -> I don't want Parcel to manage tasks orchestration, like [gulp.series(..)] allows
 * -> I want Parcel to have one clear, simple, important responsibility : to manage dependencies.
 * -> I already have npm to manage dependencies, actually npm packages depenjdencies.
 * -> But in a static website project, not all dependencies can be managed easily using npm only :
 *   +> with npm package, you can manage dependencies such as importing css libraries
 *   +> with npm package, it is harder ot manage images as dependencies
 * ->> Parcel dependencies management has features that npm does not have :
 *   +> https://parceljs.org/features/dependency-resolution/
 *   +> ccc
 **********************************************************************************
 * Global Processes List.
 * ****
 * Process list :
 * - [gulp build:debug:dev] : dev build gulp tasks debugging. Idea simply is it is a gulp.series, to define a sequence of tasks to execute the build process. Typically i would execute every single step of the build process, until the step I want to debug.
 * - [gulp build:debug:prod] : production build gulp tasks debugging. Idea simply is it is a gulp.series, to define a sequence of tasks to execute the build process. Typically i would execute every single step of the build process, until the step I want to debug.
 * - [gulp build:debug] : alias for [gulp build:debug:dev].
 * - [gulp watch:debug:dev] : watch dev build gulp tasks debugging. Uses the BrowserSync.
 * - [gulp watch:debug:prod] : watch prod build gulp tasks debugging. Uses the BrowserSync.
 **********************************************************************************
 * - [gulp build:hugo:prod] : executes the hugo build for production environment : the result of the build is in the "./public/" folder, whereas the result of the gulp build is in the "dist/" folder.
 * - [gulp build:hugo:dev] : executes the hugo build for dev environment : the result of the build is in the "./public/" folder, whereas the result of the gulp build is in the "dist/" folder.
 **********************************************************************************
 * - [gulp build:sass:prod] : executes the sass compilation for production environment : the files are fprocessed from 'public/sass' folder, and the result is put in the "./dist/css" folder.
 * - [gulp build:sass:dev] : executes the sass compilation for dev environment : the files are fprocessed from 'public/sass' folder, and the result is put in the "./dist/css" folder.
 **********************************************************************************
 * - [gulp build:dist:html:prod] : copies all the HTML files from the "./public/" folder, to the "./dist/" folder.
 * - [gulp build:dist:html:dev] : copies all the HTML files from the "./public/" folder, to the "./dist/" folder.
 **********************************************************************************
 * - [gulp build:prod] : builds for production : the source code is minified, obfuscated, optimized and not human readable (not fit for debug) (purge, minifications etc..)
 * - [gulp build:dev] : builds for dev : the result of the build in the public folder is beautified , so that it is perfect for debug purpose, very human readable
 **********************************************************************************
 * - [gulp watch:dev] : serving the './dist/' folder, after a dev build
 * - [gulp watch:prod] : serving the './dist/' folder, after a production build
 * - [gulp watch] : alias for [gulp watch:dev]
 **********************************************************************************
 * - [gulp ci:tests:cypress] : run all cypress tests
 * - [gulp ci:tests:unit] : run all unit tests
 **********************************************************************************
 * - [gulp clean:hugo:dev] : deletes the './public/' folder and re-creates it fresh and empty
 * - [gulp clean:hugo:prod] : deletes the './public/' folder and re-creates it fresh and empty
 * - [gulp clean] : executes [gulp clean:hugo:dev], and then deletes the './dist/' folder and re-creates it fresh and empty.
 **********************************************************************************
 * https://medium.com/dwarves-foundation/automatically-lint-prettify-your-javascript-project-using-husky-lint-staged-cae8e685bb06
 * https://codeburst.io/continuous-integration-lint-staged-husky-pre-commit-hook-test-setup-47f8172924fc
 **********************************************************************************
 */

 /***************************************************************
  ***************************************************************
  *  ==>>>   | beautify the HTML/JS/CSS produced by hugo in public/ folder
  ***************************************************************
  ***************************************************************
  **/
import dotenvModule from 'dotenv';
const dotenv = dotenvModule.config();

import gulp from 'gulp';


import browserSyncModule from 'browser-sync';
const browserSync = browserSyncModule.create();

import nodeSassModule from 'node-sass';
import sassModule from 'gulp-sass';
const sassCompiler = sassModule(nodeSassModule);

import pug from 'gulp-pug';

import purgecss from 'gulp-purgecss';

import gutil from 'gulp-util';

import del from 'del';
import fs from 'fs';

import shell from 'shelljs';
// const fs   = require('fs');
// const fs   = require('fs');

/// export PATH=$PATH:/usr/local/go/bin
const hugoBaseURL = `${process.env.HUGO_BASE_URL}`; /// export HUGO_BASE_URL=http://${HUGO_HOST}:${HUGO_PORT}/
const hugoHost = `${process.env.HUGO_HOST}`; /// export HUGO_HOST=127.0.0.1
const hugoPort = `${process.env.HUGO_PORT}`; /// export HUGO_PORT=4545

gulp.task('testEnvDisplay', () => {
  gutil.log(`// >>>>>>>>>>>> >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> + //`)
  gutil.log(` >>>>>>>>>>>> testEnvDisplay() >> {hugoBaseURL|HUGO_BASE_URL}=[${hugoBaseURL}]`)
  gutil.log(` >>>>>>>>>>>> testEnvDisplay() >> {hugoHost|HUGO_HOST}=[${hugoBaseURL}]`)
  gutil.log(` >>>>>>>>>>>> testEnvDisplay() >> {hugoPort|HUGO_PORT}=[${hugoBaseURL}]`)
  gutil.log(`// >>>>>>>>>>>> >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> + //`)
  gutil.log(`// >>>>>>>>>>>> >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> +  >>>>>>>>>> + //`)
  return gulp.pipe(browserSync.stream());
})


/***************************************************************
 *  ==>>>   | Clean (public folder)
 **/
import clean from 'gulp-dest-clean';
/// https://www.npmjs.com/package/gulp-clean
import cclean from 'gulp-clean';
import newer from 'gulp-newer';



var hugoPrjFolder = './';
var hugoPublicFolder = 'public';
var hugoDistFolder= './dist/';

gulp.task('clean:hugo:dev', function () {
  return gulp.src(hugoPublicFolder, {read: false, allowEmpty: true})
        .pipe(cclean())
        .pipe(gulp.dest('./'))
        .pipe(browserSync.stream());
});
gulp.task('clean:hugo:prod', function () {
  return gulp.src(hugoPublicFolder, {read: false, allowEmpty: true})
        .pipe(cclean())
        .pipe(gulp.dest('./'))
        .pipe(browserSync.stream());
});
gulp.task('clean:dist:dev', function () {
  return gulp.src(hugoDistFolder, {read: false, allowEmpty: true})
        .pipe(cclean())
        .pipe(gulp.dest('./'))
        .pipe(browserSync.stream());
});
gulp.task('clean:dist:prod', function () {
  return gulp.src(hugoDistFolder, {read: false, allowEmpty: true})
        .pipe(cclean())
        .pipe(gulp.dest('./'))
        .pipe(browserSync.stream());
});
// ---------------
/// gulp.task('clean', gulp.series('clean:hugo', 'sass:clean', 'interpolate:html:clean'));
gulp.task('clean:dev', gulp.series('clean:hugo:dev', 'clean:dist:dev'));
gulp.task('clean:prod', gulp.series('clean:hugo:prod', 'clean:dist:prod'));

/***************************************************************
 *  ==>>>   | Excute hugo build (will egenrae the website in public)
 **/

import child_process from 'child_process';
// Run Hugo to copy finished files over to public folder


gulp.task("build:hugo:prod", (done) => {
 let hugo = child_process.spawn(`hugo`, [`-b`, `${hugoBaseURL}`])
             .on("close", () => {
                 done(); // let gulp know the task has completed
             });
 let hugoLogger = function (buffer) {
     buffer.toString()
     .split(/\n/)
     .forEach(function (message) {
         if (message) {


             gutil.log("GoHugo.io: " + ` >>>>>>>>>>>> testEnvDisplay() >> {hugoBaseURL|HUGO_BASE_URL}=[${hugoBaseURL}]`);
             gutil.log("GoHugo.io: " + message);
             gutil.log("GoHugo.io: " + message);
         }
     });
 };

 hugo.stdout.on("data", hugoLogger);
 hugo.stderr.on("data", hugoLogger)
});


gulp.task("build:hugo:dev", (done) => {

  // Run hugo cli synchronously
  /*
  shell.echo(`===========================================================`)
  shell.echo(`Wil execute hugo build command : [hugo -b ${hugoBaseURL}]`)
  let hugoBuildCmd = shell.exec(`hugo -b ${hugoBaseURL}`);
  shell.echo (hugoBuildCmd.stdout)
  if (hugoBuildCmd.code !== 0) {
    shell.echo (hugoBuildCmd.stderr)
    shell.echo('Error: hugo Build failed');
    shell.exit(1);
  } else {
    done()
  }
  */
 let hugoProcess = child_process.spawn(`hugo`, [`-b`, `${hugoBaseURL}`])
             .on("close", () => {
                 done(); // let gulp know the task has completed
             });
 let hugoLogger = function (buffer) {
     buffer.toString()
     .split(/\n/)
     .forEach(function (message) {
         if (message) {


             gutil.log("GoHugo.io: " + ` >>>>>>>>>>>> testEnvDisplay() >> {hugoBaseURL|HUGO_BASE_URL}=[${hugoBaseURL}]`);
             gutil.log("GoHugo.io: " + message);
             gutil.log("GoHugo.io: " + message);
         }
     });
 };

 hugoProcess.stdout.on("data", hugoLogger);
 hugoProcess.stderr.on("data", hugoLogger)


});



/***************************************************************
 ***************************************************************
 *  ==>>>   | Compile Sass / SCSS
 ***************************************************************
 ***************************************************************
 **/

import rename from 'gulp-rename';
import autoprefixer from 'gulp-autoprefixer';
import sourcemaps from 'gulp-sourcemaps';
// Compile sassCompiler into CSS : to be used BEFORE hugo build
gulp.task('build:sass:dev', function () {
  return gulp.src('public/sass/**/*.s?ss')
      .pipe(sourcemaps.init())
      .pipe(sassCompiler().on('error', sassCompiler.logError))
      .pipe(rename({ suffix: '.min.pokus' }))
      .pipe(sourcemaps.write('/'))
      .pipe(gulp.dest('./dist/css'))
      .pipe(browserSync.stream());
});
gulp.task('build:sass:prod', function () {
  return gulp.src('public/sass/**/*.s?ss')
      .pipe(sourcemaps.init())
      .pipe(sassCompiler().on('error', sassCompiler.logError))
      .pipe(rename({ suffix: '.min.pokus' }))
      .pipe(sourcemaps.write('/'))
      .pipe(gulp.dest('./dist/css'))
      .pipe(browserSync.stream());
});

///
/// [16:46:27] Requiring external module @babel/register
/// [16:46:37] Using gulpfile ~/radio_jaune_generation4/gulpfile.babel.js
/// [16:46:37] Starting 'build:sass:dev'...
///
///   Replace Autoprefixer browsers option to Browserslist config.
///   Use browserslist key in package.json or .browserslistrc file.
///
///   Using browsers option can cause errors. Browserslist config can
///   be used for Babel, Autoprefixer, postcss-normalize and other tools.
///
///   If you really need to use option, rename it to overrideBrowserslist.
///
///   Learn more at:
///   https://github.com/browserslist/browserslist#readme
///   https://twitter.com/browserslist
///
///
/// [16:46:37] Finished 'build:sass:dev' after 200 ms
///

/***************************************************************
 ***************************************************************
 *  ==>>>   | PUBLIC TO DIST : all copy tasks from public to dist folder
 ***************************************************************
 ***************************************************************
 **/



// ------- //
// Moves the HTML files from ./public into our ./dist folder
//
gulp.task('build:dist:html:dev', function () {
  return gulp.src('public/**/*.html')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:html:prod', function () {
    return gulp.src('public/**/*.html')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});


gulp.task('build:dist:img:dev', function () {
  return gulp
      .src([
        './**/*.png',
        './**/*.jpg',
        './**/*.gif'
      ],{
      "base" : "./public"
      })
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:img:prod', function () {
  return gulp
      .src([
        './**/*.png',
        './**/*.jpg',
        './**/*.gif'
      ],{
      "base" : "./public"
      })
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});


gulp.task('build:dist:js:dev', function () {
///   return gulp
///       .src([
///         '*.js',
///         '**/*.js',
///         '**/**/*.js',
///         '**/**/**/*.js'
///       ],{
///       "base" : "./public"
///       })
  return gulp.src('public/**/*.js')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:js:prod', function () {
///  return gulp
///      .src([
///        '*.js',
///        '**/*.js',
///        '**/**/*.js',
///        '**/**/**/*.js'
///      ],{
///      "base" : "./public"
///      })
  return gulp.src('public/**/*.js')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:css:dev', function () {
///  return gulp
///      .src([
///        '*.css',
///        '**/*.css',
///        '**/**/*.css',
///        '**/**/**/*.css'
///      ],{
///      "base" : "./public"
///      })
  return gulp.src('public/**/*.css')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:css:prod', function () {
///  return gulp
///      .src([
///        '*.css',
///        '**/*.css',
///        '**/**/*.css',
///        '**/**/**/*.css'
///      ],{
///      "base" : "./public"
///      })
  return gulp.src('public/**/*.css')
      .pipe(gulp.dest("dist/"))
      .pipe(browserSync.stream());
});
gulp.task('build:dist:vendor:dev', function () {
  return gulp
      .src(['public/vendor/*'])
      .pipe(gulp.dest("dist/vendor")).pipe(browserSync.stream());
});
gulp.task('build:dist:vendor:prod', function () {
  return gulp
      .src(['public/vendor/*'])
      .pipe(gulp.dest("dist/vendor")).pipe(browserSync.stream());
});



gulp.task('build:dist:dev', gulp.series('build:dist:css:dev', 'build:dist:js:dev', 'build:dist:html:dev', 'build:dist:vendor:dev', 'build:dist:img:dev'));
gulp.task('build:dist:prod', gulp.series('build:dist:css:prod', 'build:dist:js:prod', 'build:dist:html:prod', 'build:dist:vendor:prod', 'build:dist:img:prod'));


/// ---------- -------------------------------- ///
/// ---------- GULP HTML REPLACE
/// <!-- build:<name> -->
/// Everything here will be replaced
/// <!-- endbuild -->
/// <!-- build:radiojaune_compiled_sass -->
/// Everything here will be replaced
/// <!-- endbuild -->
import htmlreplace from 'gulp-html-replace';
import gulpTap from 'gulp-tap';
import merge from 'gulp-merge';
// Compile sassCompiler into CSS : to be used BEFORE hugo build
/// interpolate:html:dev
gulp.task('interpolate:html:prod', function (done) {
/// //  htmlreplace({
/// //    radiojaune_compiled_sass3: {// Multiple tag replacement one for each sass scss compiled source file
/// //      // src: [['data-main.js', 'require-src.js']],
/// //      // src: ['static/sass/**/*.s?ss', ['data-main.js', 'require-src.js']],
/// //      // src: ['public/sass/**/*.s?ss', ['data-main.js', 'require-src.js']],
/// //      src: [['data-main.js', 'require-src.js']],
/// //      tpl: '<link href="%s" rel="stylesheet">'
/// //    }
/// //  })

  let multiPlaceHolderhtmlTemplateToInject = ''
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  /// -- // -
  let htmlTemplateToInject = '<link href="%s" rel="stylesheet">\r\n'
  // let compiledSassFiles = [ ['dist/css/a.min.pokus'], ['b.min.pokus.js'], ['c.min.pokus.js'], ['dist/css/pour.tests.gulp/encore.autre.pour.test.min.pokus.css'], ['data-main.js'], ['require-src.js'], ['dist/css/yellow-share.min.pokus.css'], ['dist/css/yellow-share.min.pokus.css.map']]
  // compiledSassFiles.push([ `petit test ajouté à la volée` ])
  let compiledSassFiles = []
  /// compiledSassFiles.push([ `dist/css/yellow-share.min.pokus.css` ])
  /// compiledSassFiles.push([ `dist/css/yellow-share.min.pokus.css.map` ])
  /// compiledSassFiles.push([ `dist/css/yellow-carousel.min.pokus.css` ])
  /// compiledSassFiles.push([ `dist/css/yellow-carousel.min.pokus.css.map` ])

  compiledSassFiles.push([ `/css/yellow-share.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-share.min.pokus.css.map` ])
  compiledSassFiles.push([ `/css/yellow-carousel.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-carousel.min.pokus.css.map` ])
  compiledSassFiles.push([ `/css/yellow-glitch.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-glitch.min.pokus.css.map` ])

  var compiledSassFilesLinksResolition = gulp.src('public/sass/**/*.s?ss')
                            .pipe(gulpTap(function(file, t) {
                                gutil.log(`POKUS-gulp[interpolate:html:prod] : file.path=[${file.path}]`)
                                compiledSassFiles.push([ `${file.path}` ])
                            }))

  var htmlReplaceWork = gulp.src('dist/**/*.html')
                            .pipe(htmlreplace({
                                radiojaune_compiled_sass: {// Multiple tag replacement one for each sass scss compiled source file
                                  // src: [ ['dist/css/a.min.pokus', 'b.min.pokus.js', 'c.min.pokus.js'], ['dist/css/pour.tests.gulp/encore.autre.pour.test.min.pokus.css', 'data-main.js', 'require-src.js']],
                                  // tpl: multiPlaceHolderhtmlTemplateToInject
                                  src: compiledSassFiles,
                                  tpl: htmlTemplateToInject
                                }
                              }))
                            .pipe(gulp.dest('dist'))

  /// return merge(compiledSassFilesLinksResolition, htmlReplaceWork)
  ///       .pipe(browserSync.stream()); // merge and watch do not work well together, see https://github.com/gulpjs/gulp/issues/593 (I had an error which i solved by skimming out the merge commands. Suggestion was made to replace a merge by a gulp-if , that's an idea to bear in mind). My Error was 'TypeError: this.__data__.get is not a function'
  //

  return htmlReplaceWork.pipe(browserSync.stream());
});

gulp.task('interpolate:html:dev', function (done) {


  let multiPlaceHolderhtmlTemplateToInject = ''
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  multiPlaceHolderhtmlTemplateToInject += '<link href="%s" rel="stylesheet">\r\n'
  /// -- // -
  let htmlTemplateToInject = '<link href="%s" rel="stylesheet">\r\n'
  // let compiledSassFiles = [ ['dist/css/a.min.pokus'], ['b.min.pokus.js'], ['c.min.pokus.js'], ['dist/css/pour.tests.gulp/encore.autre.pour.test.min.pokus.css'], ['data-main.js'], ['require-src.js']]
  let compiledSassFiles = [ ]
  /// compiledSassFiles.push([ `dist/css/autre.pour.test.min.pokus.css` ])
  /// compiledSassFiles.push([ `dist/css/autre.pour.test.min.pokus.css.map` ])

  compiledSassFiles.push([ `/css/autre.pour.test.min.pokus.css` ])
  compiledSassFiles.push([ `/css/autre.pour.test.min.pokus.css.map` ])

  compiledSassFiles.push([ `/css/yellow-carousel.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-carousel.min.pokus.css.map` ])

  compiledSassFiles.push([ `/css/yellow-share.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-share.min.pokus.css.map` ])

  compiledSassFiles.push([ `/css/yellow-glitch.min.pokus.css` ])
  compiledSassFiles.push([ `/css/yellow-glitch.min.pokus.css.map` ])


  var compiledSassFilesLinksResolition = gulp.src('public/sass/**/*.s?ss')
                            .pipe(gulpTap(function(file, t) {
                                gutil.log(`POKUS-gulp[interpolate:html:prod] : file.path=[${file.path}]`)
                                compiledSassFiles.push([ `${file.path}` ])
                            }))

  var htmlReplaceWork = gulp.src('public/**/*.html')
                            .pipe(htmlreplace({
                                radiojaune_compiled_sass: {// Multiple tag replacement one for each sass scss compiled source file
                                  // src: [ ['dist/css/a.min.pokus', 'b.min.pokus.js', 'c.min.pokus.js'], ['dist/css/pour.tests.gulp/encore.autre.pour.test.min.pokus.css', 'data-main.js', 'require-src.js']],
                                  // tpl: multiPlaceHolderhtmlTemplateToInject
                                  src: compiledSassFiles,
                                  tpl: htmlTemplateToInject
                                }
                              }))
                            .pipe(gulp.dest('dist'))

  return merge(compiledSassFilesLinksResolition, htmlReplaceWork)
        .pipe(browserSync.stream());
});






/***************************************************************
 ***************************************************************
 *  ==>>>   | Execute Image processing tasks (from 'dist/' to 'dist/')
 ***************************************************************
 ***************************************************************
 **/

/// --- ------ --- ///
/// --- Design --- ///
/// * purpose 1 [gulp "build:img:effects:dev"] : add effects on images using ImageMagick :
///   * There is no gulp-imagemagick plugin,
///   * There are plugins using ImageMagick features to resize images for example,
///   * but A./ I want to use ImageMagick special effects commands, not resizing commands
///   * and B./ I want a plugin which allows me to run any ImageMagick commands, not only resizing  commands
///   * so i will use child_process and shelljs to run imagemagick commands
/// * purpose 2 [gulp "build:img:resize:dev"] : For each image file, generate 3 to 5 resized images, using sharp / `gulp-sharp`
/// * purpose 3 [gulp "build:img:compress:dev"] : compress all images files, will be done using imagemin / `gulp-imagemin`
/// --- ------ --- ///



/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- Add effects on images  -- --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///

/**
 * The ImageMagick command-line tools exit with
 * a status of 0 if the command line arguments have
 * a proper syntax and no problems are encountered.
 * ---
 * Expect a descriptive message and an exit status of
 * 1 if any exception occurs such as improper syntax, a
 * problem reading or writing an image, or any other
 * problem that prevents the command from
 * completing successfully.
 * ---
 **/


 gulp.task("build:img:effects:dev", (done) => {
   // --- // --- //
   // Run ImageMagick CLI synchronously
   /*
   shell.echo(`===========================================================`)
   shell.echo(`Wil execute hugo build command : [hugo -b ${hugoBaseURL}]`)
   let hugoBuildCmd = shell.exec(`hugo -b ${hugoBaseURL}`);
   shell.echo (hugoBuildCmd.stdout)
   if (hugoBuildCmd.code !== 0) {
     shell.echo (hugoBuildCmd.stderr)
     shell.echo('Error: hugo Build failed');
     shell.exit(1);
   } else {
     done()
   }
   */
  let imagemagickProcess = child_process.spawn(`hugo`, [`-b`, `${hugoBaseURL}`])
              .on("close", () => {
                  done(); // let gulp know the task has completed
              });
  let hugoLogger = function (buffer) {
      buffer.toString()
      .split(/\n/)
      .forEach(function (message) {
          if (message) {


              gutil.log("GoHugo.io: " + ` >>>>>>>>>>>> testEnvDisplay() >> {hugoBaseURL|HUGO_BASE_URL}=[${hugoBaseURL}]`);
              gutil.log("GoHugo.io: " + message);
              gutil.log("GoHugo.io: " + message);
          }
      });
  };

  imagemagickProcess.stdout.on("data", hugoLogger);
  imagemagickProcess.stderr.on("data", hugoLogger)


 });




/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- Generate resized images   --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///

/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- Compress all images files --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///
/// --- ------ --- /// --- ------ --- /// --- ------ --- ///


// --- If I use gulp-imagemin [^8.0.0], I gt an error.
//     This error is caused by the fact that gulp-imagemin [^8.0.0] and above are now ESM only. You can downgrade gulp-imagemin to 7.1.0 which is commonjs and it should work fine.
import imagemin from 'gulp-imagemin';

import pngquant from 'imagemin-pngquant';

 /// export default () => (
 /// 	gulp.src('src/images/*')
 /// 		.pipe(imagemin())
 /// 		.pipe(gulp.dest('dist/images'))
 /// );




gulp.task('build:img:dev', () => {
  //return gulp.src('src/images/*')
  return gulp
      .src([
        'img/**/*.svg',
        'img/**/*.ico',
        'img/**/*.png',
        'img/**/*.jpg',
        'images/**/*.svg',
        'images/**/*.ico',
        'images/**/*.jpg',
        'images/**/*.png'
      ],{
      "base" : "./dist"
      })
		.pipe(imagemin({
			progressive: true,
			svgoPlugins: [{removeViewBox: false}],
			use: [pngquant()]
		}))
		.pipe(gulp.dest('dist/'));
});

gulp.task('build:img:prod', () => {
  return gulp
      .src([
        'img/**/*.png',
        'img/**/*.jpg',
        'images/**/*.jpg',
        'images/**/*.png'
      ],{
      "base" : "./dist"
      })
		.pipe(imagemin({
			progressive: true,
			svgoPlugins: [{removeViewBox: false}],
			use: [pngquant()]
		}))
		.pipe(gulp.dest('dist/'));
});

/***************************************************************
 ***************************************************************
 *  ==>>>   | Excute SEO tasks (in the website in public)
 ***************************************************************
 ***************************************************************
 **/

import find from 'gulp-find';
import replace from 'gulp-replace';
import path from 'path';

import useref from 'gulp-useref';
import gulpif from 'gulp-if';
import minifyCss from 'gulp-clean-css';

import gulpSeo from 'gulp-seo';

gulp.task('seo', function() {
  const radioJauneConfiguration = {
        list: ['og', 'se', 'schema', 'twitter', 'facebook'],
        meta: {
            title: 'RADIOJAUNE.COM',
            description: 'La radio libre 100%Jaune, Libre antenne tous les Dimanches 21h',
            author: 'RADIOJAUNE.COM',
            keywords: ['radio', 'libre', 'libre antenne', 'live', 'gilets jaunes', 'convoi des libertés', 'freedom convoy', 'free speech', 'liberté d\'expression', 'émission', 'censure', 'censure facebook', 'citoyen', 'débats', 'scandale', 'polémiques', 'covid', 'vaccin', 'pass sanitaire', 'pass vaccinal', 'green pass', 'vaccin', 'démocratie', 'convergence'],
            robots: {
                index: true, // true
                follow: true // true
            },
            revisitAfter: '5 month', // 3 month
            image: 'https://radiojaune.com/images/radiojaune/favicon.next/favicon.48x48.ico',
            site_name: 'RADIOJAUNE.COM',
            type: 'website'

        }
    }

    return gulp.src('public/**/*.html')
              .pipe(gulpSeo(radioJauneConfiguration))
              .pipe(gulp.dest('./public'))
              .pipe(browserSync.stream());
});
/***************************************************************
 ***************************************************************
 *  ==>>>   | beautify the HTML/JS/CSS produced by hugo in public/ folder
 ***************************************************************
 ***************************************************************
 **/
import gulpBeautify from 'gulp-beautify';
gulp.task('beautifyHugoPublicHtml', function() {
  return gulp
    .src('./public/**/*.html')
    .pipe(gulpBeautify.html({ indent_size: 2 }))
    .pipe(gulp.dest('./public/'));
});
gulp.task('beautifyHugoPublicCss', function() {
  return gulp
    .src('./public/**/*.css')
    .pipe(gulpBeautify.css({ indent_size: 2 }))
    .pipe(gulp.dest('./public/'));
});

gulp.task('beautifyHugoPublicJs', function() {
  // gulp-beautify exports are identical to js-beautify programmatic access
  // so beautify() is the old pattern for beautify.js()
  return gulp
    .src('./public/**/*.js')
    .pipe(gulpBeautify({ indent_size: 2 }))
    .pipe(gulp.dest('./public/'));
});

gulp.task('beautifyHugoPublic', gulp.series('beautifyHugoPublicHtml', 'beautifyHugoPublicCss', 'beautifyHugoPublicJs'));

/***************************************************************
 ***************************************************************
 *  ==>>>   | minify the HTML/JS/CSS produced by gulp in dist/ folder
 ***************************************************************
 ***************************************************************
 **/
import minify from 'gulp-minify';
gulp.task('minifyJSHugo', () => {
    return   gulp.src(['dist/**/*.js'])
        .pipe(minify())
        .pipe(gulp.dest('dist'))
        .pipe(browserSync.stream());
})


import cleanCSS from 'gulp-clean-css';

gulp.task('minifyCSSHugo',() => {
  return gulp.src('./dist/css/*.css')
    .pipe(sourcemaps.init())
    .pipe(cleanCSS())
    .pipe(sourcemaps.write())
    .pipe(gulp.dest('dist/css'));
});


gulp.task('minifyHugoDist', gulp.series('minifyJSHugo', 'minifyCSSHugo'));


/***************************************************************
 ***************************************************************
 *  ==>>>   | uglify the HTML/JS/CSS produced by gulp in dist/ folder
 ***************************************************************
 ***************************************************************
 **/
import uglify from 'gulp-uglify';
import pipelineModule from 'readable-stream';
const pipeline = pipelineModule.pipeline;

gulp.task('uglifyJSHugo', function () {
  return pipeline(
        gulp.src([
          'dist/*.js',
          'dist/**/*.js',
          'dist/**/**/*.js',
          'dist/**/**/**/*.js'
        ]),
        uglify(),
        gulp.dest('dist')
  );
});

gulp.task('uglifyHugoDist', gulp.series('minifyJSHugo'));




/***************************************************************
 ***************************************************************
 *  ==>>>   | purge CSS produced by gulp in dist/ folder
 ***************************************************************
 ***************************************************************
 **/
gulp.task('purgecss', () => {
    return gulp.src('src/**/*.css')
        .pipe(purgecss({
            content: [
              'src/*.html',
              'src/**/*.html'
            ]
        }))
        .pipe(gulp.dest('build/css'))
})





// ---------------
// all prod env related tasks are done in the dist folder itself
// all dev env rerleated ops are done inside the public folder
// the docs/ folder is only used by github pages deployment
//
// gulp.task('build:debug', gulp.series('build:hugo:dev', 'interpolate:html:prod'));
// gulp.task('build:debug', gulp.series('build:hugo:dev', 'build:sass:dev', 'interpolate:html:prod'));

gulp.task('build:debug:dev', gulp.series('clean:dev', 'build:hugo:dev', 'build:sass:dev', 'build:dist:dev', 'build:dist:dev', 'build:dist:dev', 'build:img:dev', 'interpolate:html:dev'));
/// gulp.task('build:debug:dev', gulp.series('clean:dev', 'build:hugo:dev', 'build:sass:dev', 'build:dist:dev', 'interpolate:html:dev', 'build:dist:dev', 'build:img:dev'));
gulp.task('build:debug', gulp.series('build:debug:dev'));
/// gulp.task('build:debug:dev', gulp.series('build:hugo:dev', 'build:sass:dev', 'interpolate:html:dev'));

gulp.task('build:debug:prod', gulp.series('build:hugo:prod', 'build:sass:prod'));
/// gulp.task('build:debug:prod', gulp.series('build:hugo:prod', 'sass:prod', 'interpolate:html:prod'));


gulp.task('build:dev', gulp.series('build:sass:dev', 'build:hugo:dev', 'seo', 'beautifyHugoPublic', 'clean:dist:dev', 'build:dist:dev', 'purgecss', 'minifyJSHugo', 'uglifyJSHugo',));
gulp.task('build:prod', gulp.series('build:sass:dev', 'build:hugo:prod', 'seo', 'minifyJSHugo', 'uglifyJSHugo'));


gulp.task('watch:prod', gulp.series('build:prod', function() {
    browserSync.init({
        server: "./dist",
        host: `${hugoHost}`,
        port: `${hugoPort}`
    });

    // watch all hugo project files for change, rebuild all if changes
    gulp.watch('./config.toml', gulp.series('build:hugo:dev', 'build:dist:dev'));
    gulp.watch('./config.yaml', gulp.series('build:hugo:dev', 'build:dist:dev'));
    gulp.watch('./config.json', gulp.series('build:hugo:dev', 'build:dist:dev'));
    gulp.watch('./static/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./assets/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./themes/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./archetypes/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./content/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./data/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch('./layouts/**/*.*', gulp.series('build:hugo:dev', 'build:sass:dev', 'purgecss', 'build:dist:dev'));
    gulp.watch("src/*.html").on('change', browserSync.reload);
}));




gulp.task('watch:debug:dev', gulp.series('build:debug:dev', function() {
    gutil.log(`POKUS : hugoHost=[${hugoHost}]`)
    gutil.log(`POKUS : hugoPort=[${hugoPort}]`)

    browserSync.init({ // https://browsersync.io/docs/api
        server: "./dist",
        host: `${hugoHost}`,
        port: `${hugoPort}`
    });

    // watch all hugo project files for change, rebuild all if changes
    gulp.watch('./config.toml', gulp.series('build:debug:dev'));
    gulp.watch('./config.yaml', gulp.series('build:debug:dev'));
    gulp.watch('./config.json', gulp.series('build:debug:dev'));
    gulp.watch('./static/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./assets/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./themes/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./archetypes/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./content/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./data/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./layouts/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./layouts/**/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch('./layouts/**/**/**/*.*', gulp.series('build:debug:dev'));
    gulp.watch("layouts/**/*.html", gulp.series('build:debug:dev')).on('change', browserSync.reload);
}));
gulp.task('watch:debug:prod', function() {
    gutil.log(`POKUS : hugoHost=[${hugoHost}]`)
    gutil.log(`POKUS : hugoPort=[${hugoPort}]`)

    browserSync.init({ // https://browsersync.io/docs/api
        server: "./dist",
        host: `${hugoHost}`,
        port: `${hugoPort}`
    });

    // watch all hugo project files for change, rebuild all if changes
    gulp.watch('./config.toml', gulp.series('build:debug:prod'));
    gulp.watch('./config.yaml', gulp.series('build:debug:prod'));
    gulp.watch('./config.json', gulp.series('build:debug:prod'));
    gulp.watch('./static/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./assets/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./themes/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./archetypes/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./content/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./data/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch('./layouts/**/*.*', gulp.series('build:debug:prod'));
    gulp.watch("layouts/**/*.html", gulp.series('build:debug:prod')).on('change', browserSync.reload);
});
